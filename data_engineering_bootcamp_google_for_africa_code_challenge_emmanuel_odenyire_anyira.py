# -*- coding: utf-8 -*-
"""Data Engineering Bootcamp- Google for Africa code challenge - Emmanuel Odenyire Anyira.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16_rilLqvO2IDDcMxMbi0FGS6Cjf5wkGY

# Data Bootcamp Selection Challenge

## Project Description

In this challenge, I am working with a car-based dataset to calculate various Key Performance Indicators (KPIs). Each question has a single correct answer, which will be evaluated through automated unit testing. The challenge includes questions related to data analysis, aggregation, and calculations.

## Instructions

1. **Dataset**: The dataset has already been provided. Do not perform any data cleaning or modifications to the dataset.

2. **Answer Dictionary**: Use the provided answer dictionary to store your answers. Do not modify the structure of the answer dictionary. For each question, replace the value with your calculated answer.

3. **Coding**: Solve each question by writing the necessary code using the given dataset. Use the examples and code snippets provided in the challenge description as references.

4. **Saving Answers**: After solving all the questions and filling in the answer dictionary, save your answers in pickle format using the provided code.

5. **GitHub Repository**: Upload your Jupyter notebook and the pickle file containing the answer dictionary to a public GitHub repository. Create a new repository if needed.

6. **Submission**: Submit the URLs of both your Jupyter notebook and the pickle file through the provided Google form. Ensure that the URLs are accessible and correct.

## My Task

My task is to complete the coding challenges presented in this notebook. I am to follow the provided examples and guidelines to calculate the required KPIs and ensure that my answers are in the correct format as specified in each question.

---

**Note**: The unit tests provided at the end of this notebook will help us verify the correctness of our answers. However, they are not exhaustive, so make sure to review your answers carefully before submission.
"""

#Use this dictionary to store your answers in the correct format in the cells below , do not modify the keys
answer_dict =  {"Q1" : None,
                "Q2" : None,
                "Q3" : None,
                "Q4" : None,
                "Q5" : None,
                "Q6" : None,
                "Q7" : None}

"""# Data Bootcamp Selection Challenge

## Reading the Dataset

In this challenge, you will work with a car-based dataset to calculate various Key Performance Indicators (KPIs). The dataset contains information about different car models, their attributes, and fuel efficiency metrics. You will use this dataset to answer specific questions related to the provided challenges.

To get started, follow the instructions below to read the dataset into a DataFrame using the pandas library.

### Instructions

1. Import the required library, pandas.
2. Specify the URL of the dataset.
3. Read the dataset into a DataFrame using the `pd.read_csv()` function.
4. Display the first few rows of the DataFrame to ensure successful loading.

Remember, you can use any Python library to solve this challenge, but we recommend using pandas due to its ease of use and compatibility with the given dataset.

Let's begin by reading the dataset and exploring the initial data.

# Data Bootcamp Selection Challenge

## Reading the Dataset

In this step, we will read the car-based dataset into a DataFrame using the pandas library. The dataset contains information about various car models, their attributes, and fuel efficiency metrics.

We will use the following code to accomplish this:

```python
import pandas as pd
import numpy as np

# URL of the dataset
url = "https://storage.googleapis.com/deb-evaluation-materials/vehicles.csv"

# Read the dataset into a DataFrame using pandas
df = pd.read_csv(url)
"""

import pandas as pd
import numpy as np
url = "https://storage.googleapis.com/deb-evaluation-materials/vehicles.csv"
df = pd.read_csv(url)

"""Let's execute the code and load the dataset for further analysis.

# Data Bootcamp Selection Challenge

## Exploring the Initial Data

After successfully reading the dataset into a DataFrame, let's take a look at the initial data. The `df.head()` function allows us to display the first few rows of the DataFrame to get a glimpse of the data's structure and content.

Let's execute the code below to see the first few rows of the dataset:

```python
df.head()
"""

df.head()

"""# Data Bootcamp Selection Challenge

## Dataset Information

Let's explore further details about the dataset using the `df.info()` function. This function provides information about the columns, non-null counts, and data types present in the DataFrame. The output below summarizes the dataset's structure:


"""

df.info()

"""Q1. What is the average CO2 emmission per gram/mile of all Volkswagen cars?
Format: A floating number
Example answer:
11.547
"""

# Calculate the average CO2 emission per gram/mile of all Volkswagen cars
average_co2_emission = df[df['Make'] == 'Volkswagen']['CO2 Emission Grams/Mile'].mean()

# Update the answer dictionary with the calculated result
answer_dict["Q1"] = average_co2_emission

# Print the calculated result
print("Average CO2 emission per gram/mile of all Volkswagen cars:", average_co2_emission)

"""Q2. Calculate the top 5 brands(Make) with the most unique models, order your answer in descending order with respect to the number of unique models.
NOTE: Consider only the name of the models and their brand, that is use only the Make and Model columns
Format: A 5X2 list with each row being the name of the brand followed by the unique number of models, in descending order.
Hint: You can use the pandas df.values.tolist() function to format your answer.
Example answer:
[["Volkswagen", 1000], ["Toyota", 900], ["Honda", 800], ["Subaru", 700], ["Ford", 600]]
"""

# Calculate the top 5 brands with the most unique models
top_brands_unique_models = df.groupby('Make')['Model'].nunique().sort_values(ascending=False).head(5)

# Convert the result to the required format
top_brands_unique_models_list = top_brands_unique_models.reset_index().values.tolist()

# Update the answer dictionary with the calculated result
answer_dict["Q2"] = top_brands_unique_models_list

# Print the calculated result
print("Top 5 brands with the most unique models:")
for brand, num_models in top_brands_unique_models_list:
    print(brand, num_models)

"""Q3. What are all the different types of fuels in the dataset sorted alphabetically?
Format: A list of strings sorted alphabetically.
Example Answer:
['Regular', 'Premium']
"""

# Get the different types of fuels and sort them alphabetically
fuel_types = sorted(df['Fuel Type'].unique())

# Update the answer dictionary with the calculated result
answer_dict["Q3"] = fuel_types

# Print the list of fuel types
print("Different types of fuels sorted alphabetically:")
print(fuel_types)

"""Q4. Show the 9 Toyota cars with the most extreme Fuel Barrels/Year in abosolute terms within all Toyota cars. Show the car Model, Year and their Fuel Barrels/Year in standard deviation units(Z-score) sorted in descending order by their Fuel Barrels/Year in absolute terms first and then by year in descending order BUT without modifying the negative values (see example).
Format: A 9X3 list with each row containing the Model, Year and Fuel Barrels/Year in standard deviations units
Example answer:
[['DJ Po Vehicle 2WD', 2004, -6.407431084026927],
 ['FJ8c Post Office', 2003, -6.407431084026927],
 ['Post Office DJ5 2WD', 2005, -6.391684618442447],
 ['Sierra 2500 Hd 2WD', 2002, -6.391684618442447],
 ['Camry CNG', 2012, 2.677633075759575],
 ['Sierra 1500 4WD', 2005, 2.677633075759575],
 ['Sierra 1500 4WD', 2001, 2.677633075759575],
 ['V15 Suburban 4WD', 1988, 2.677633075759575],
 ['V15 Suburban 4WD', 1987, 2.677633075759575]]
Note that while the list is sorted by the Fuel Barrels/Year in absolute terms and in standard deviation units, the values are not modified. If the values are the same the rows are sorted by the year.
"""

# Calculate Z-scores for Fuel Barrels/Year within Toyota cars
toyota_cars = df[df['Make'] == 'Toyota']
toyota_cars['Fuel Barrels/Year Z-score'] = (toyota_cars['Fuel Barrels/Year'] - toyota_cars['Fuel Barrels/Year'].mean()) / toyota_cars['Fuel Barrels/Year'].std()

# Filter out negative Z-scores and sort by absolute value and year
extreme_toyota_cars = toyota_cars[abs(toyota_cars['Fuel Barrels/Year Z-score']) > 0].sort_values(by=['Fuel Barrels/Year Z-score', 'Year'], ascending=[False, False])

# Select the top 9 extreme Toyota cars
top_extreme_toyota_cars = extreme_toyota_cars.head(9)[['Model', 'Year', 'Fuel Barrels/Year Z-score']].values.tolist()

# Update the answer dictionary with the calculated result
answer_dict["Q4"] = top_extreme_toyota_cars

# Print the list of extreme Toyota cars
print("Top 9 Toyota cars with extreme Fuel Barrels/Year:")
for car in top_extreme_toyota_cars:
    print(car)

"""Q5. Calculate the changes in Combined MPG with their previous model of all Golf cars with Manual 5-spd transmission and Regular Fuel Type. Show the Year, the Combined MPG and the calculated difference of MPG in a list sorted by Year in ascending order.
Format: A 19X3 list, with the Year and Combined MPG being of type integer and only the calculated difference is of type float
Note: The value for the first model should be 0. It does not matter that there are gaps in the years, calculate with respect the previous model.
Example answer:
[[1986, 25, 0.0],
 [1987, 25, 0.0],
 [1988, 25, 0.0],
 [1989, 25, 0.0],
 [1990, 23, -2.0],
 [1991, 23, 0.0],
 [1992, 24, 1.0],
 [1993, 25, 1.0],
 [1994, 25, 0.0],
 [1995, 25, 0.0],
 [1996, 25, 0.0],
 [1997, 25, 0.0],
 [1998, 24, -1.0],
 [1999, 25, 1.0],
 [2000, 24, -1.0],
 [2001, 24, 0.0],
 [2002, 24, 0.0],
 [2004, 24, 0.0],
 [2006, 24, 0.0]]
"""

# Filter the data for Golf cars with Manual 5-spd transmission and Regular Fuel Type
golf_cars = df[(df['Make'] == 'Volkswagen') & (df['Model'].str.contains('Golf')) & (df['Transmission'] == 'Manual 5-spd') & (df['Fuel Type'] == 'Regular')]

# Calculate the changes in Combined MPG with the previous model
golf_cars['Change in Combined MPG'] = golf_cars['Combined MPG'].diff().fillna(0)

# Select the relevant columns and sort by Year
result_q5 = golf_cars[['Year', 'Combined MPG', 'Change in Combined MPG']].values.tolist()
result_q5.sort()

# Update the answer dictionary with the calculated result
answer_dict["Q5"] = result_q5

# Print the list of changes in Combined MPG for Golf cars
print("Changes in Combined MPG for Golf cars:")
for entry in result_q5:
    print(entry)

"""Q6. What are the top 5 lowest CO2 Emission Grams/Mile emmisions of cars for each of the following brands: Toyota, Ford, Volkswagen, Nissan, Honda
Format: A 5X6 list with the first element of each row being the Make of the cars and the following five values being floats sorted in ascending order. The Makes should appear in order listed in the question starting with Toyota and ending with Honda (see example).
Example answer:
[['Toyota', 100.0, 140.0, 140.0, 150.0, 150.0],
 ['Ford',
  100.025641025641,
  200.677633075759575,
  200.677633075759575,
  200.677633075759575,
  200.677633075759575],
 ['Volkswagen', 139.0, 154.0, 166.5, 166.5, 166.5],
 ['Nissan', 122.0, 122.0, 122.0, 122.0, 160.0],
 ['Honda', 100.0, 100.0, 100.0, 100.0, 123.91684618442447]]
"""

# List of specified brands
brands = ['Toyota', 'Ford', 'Volkswagen', 'Nissan', 'Honda']

# Initialize an empty list to store the results
result_q6 = []

# Iterate through each brand and calculate the top 5 lowest CO2 Emission Grams/Mile emissions
for brand in brands:
    # Filter the data for the current brand
    brand_data = df[df['Make'] == brand]

    # Sort the data by CO2 Emission Grams/Mile in ascending order
    brand_data_sorted = brand_data.sort_values(by='CO2 Emission Grams/Mile')

    # Select the top 5 lowest emissions and add them to the result list
    lowest_emissions = brand_data_sorted[['CO2 Emission Grams/Mile']].head(5).values.tolist()
    lowest_emissions.insert(0, brand)  # Add the brand name at the beginning
    result_q6.append(lowest_emissions)

# Update the answer dictionary with the calculated result
answer_dict["Q6"] = result_q6

# Print the list of top 5 lowest emissions for each brand
print("Top 5 lowest CO2 Emission Grams/Mile emissions for each brand:")
for entry in result_q6:
    print(entry)

"""Q7. Form 7 groups of 5 years to calculated the median Combined MPG of each group. The first group is from 1984 to 1988, the second from 1989 to 1993 and so on. The last group will have years not appearing in the dataset.
Note: The groups ranges are inclusive on both sides, the first group starts with 1984 and cars from 1984 are included in it.
Format : A 7X2 list with the first element of each row being a tuple of two integers being the lower and uppper range of the year groups and the esecond element being the median Combined MPG of that group, a float number.
Example answer:
[[(1984, 1988), 11.0],
 [(1989, 1993), 10.0],
 [(1994, 1998), 10.0],
 [(1999, 2003), 14.0],
 [(2004, 2008), 13.0],
 [(2009, 2013), 14.0],
 [(2014, 2018), 15.0]]
"""

# # Calculate the median Combined MPG for each group of 5 years
# result_q7 = []
# for start_year in range(1984, 2023, 5):
#     end_year = start_year + 4
#     group_data = df[(df['Year'] >= start_year) & (df['Year'] <= end_year)]
#     median_mpg = group_data['Combined MPG'].median()
#     result_q7.append([(start_year, end_year), median_mpg])

# # Update the answer dictionary with the calculated result
# answer_dict["Q7"] = result_q7

# # Print the list of tuples containing year groups and their corresponding median Combined MPG
# print("Median Combined MPG for each group of 5 years:")
# for entry in result_q7:
#     print(entry)


# Calculate the median Combined MPG for each group of 5 years
result_q7 = []
for start_year in range(1984, 2023, 5):
    end_year = start_year + 4
    group_data = df[(df['Year'] >= start_year) & (df['Year'] <= end_year)]
    median_mpg = group_data['Combined MPG'].median()
    result_q7.append([(start_year, end_year), float(median_mpg)])  # Convert median_mpg to float

# Update the answer dictionary with the calculated result
answer_dict["Q7"] = result_q7

"""Conversion of data types to conform to the set data types in the test cases

> I have tried all the ways possible to conform to the set data types, but I am still failing 4 test cases


"""

# Convert answer_dict values to correct data types
answer_dict["Q1"] = float(answer_dict["Q1"])

answer_dict["Q2"] = [
    [str(entry[0]), int(entry[1])]
    for entry in answer_dict["Q2"]
]

answer_dict["Q3"] = sorted([str(fuel_type) for fuel_type in answer_dict["Q3"]])

answer_dict["Q4"] = [
    [str(entry[0]), int(entry[1]), float(entry[2])]
    for entry in answer_dict["Q4"]
]

answer_dict["Q5"] = [
    [int(entry[0]), int(entry[1]), float(entry[2])]
    for entry in answer_dict["Q5"]
]

answer_dict["Q6"] = [
    entry
    for entry in answer_dict["Q6"]
]

answer_dict["Q7"] = [
    [(int(entry[0][0]), int(entry[0][1])), float(entry[1])]
    for entry in answer_dict["Q7"]
]

"""Test your answers


> We provide you some tests to make sure your answer dictionary is in the correct format using unittest.

> These tests are not meant to be comprehensive, you should review all your answers carefully.

# Test Your Answers

To ensure that your answer dictionary is in the correct format, we will run a series of tests using the `unittest` framework. These tests are designed to check if your answers are structured as expected. Please review your answers and ensure that they match the required formats for each question.

**Note:** Passing these tests does not guarantee the correctness of your answers, but it does verify that your answers are in the expected format.

Below are the tests that will be run:

1. Check if `answer_dict` is a dictionary.
2. Check if the keys in `answer_dict` match the expected keys for each question.
3. Check if the values in `answer_dict` have the correct data types for each question.
4. Check specific data types and shapes for each question's answer.

Please make sure to run the test cells below to validate your answers.
"""

import unittest

class TestAnswers(unittest.TestCase):
    def test_if_dict(self):
        self.assertIsInstance(answer_dict, dict)

    def test_keys(self):
        self.assertEqual(list(answer_dict.keys()), ['Q1', 'Q2', 'Q3', 'Q4', 'Q5', 'Q6', 'Q7'])

    def test_answers_types(self):
        types_values = [type(k) for k in answer_dict.values()]
        answer_types = [float, list, list, list, list, list, list]
        self.assertEqual(types_values, answer_types)

    def test_Q1(self):
        self.assertEqual(type(answer_dict['Q1']), float)

    def test_Q2_dim(self):
        self.assertEqual(np.array(answer_dict['Q2']).shape, (5,2))

    def test_Q2_types(self):
        dtype1 = type(answer_dict['Q2'][0][0])
        dtype2 = type(answer_dict['Q2'][0][1])
        self.assertEqual([dtype1, dtype2], [str, int])

    def test_Q3_types(self):
        q3_types = set([type(item) for item in answer_dict['Q3']])
        self.assertEqual(q3_types, {str})

    def test_Q4_dim(self):
        self.assertEqual(np.array(answer_dict['Q4']).shape, (9,3))

    def test_Q4_types(self):
        dtype1 = type(answer_dict['Q4'][0][0])
        dtype2 = type(answer_dict['Q4'][0][1])
        dtype3 = type(answer_dict['Q4'][0][2])
        self.assertEqual([dtype1, dtype2, dtype3], [str, int, float])

    def test_Q5_dim(self):
        self.assertEqual(np.array(answer_dict['Q5']).shape, (19,3))

    def test_Q5_types(self):
        dtype1 = type(answer_dict['Q5'][0][0])
        dtype2 = type(answer_dict['Q5'][0][1])
        dtype3 = type(answer_dict['Q5'][0][2])
        self.assertEqual([dtype1, dtype2, dtype3], [int, int, float])

    def test_Q5_first_zero(self):
        self.assertEqual(answer_dict['Q5'][0][2], 0)


    def test_Q6_dim(self):
        self.assertEqual(np.array(answer_dict['Q6']).shape, (5,6))

    def test_Q5_types(self):
        dtype1 = type(answer_dict['Q6'][0][0])
        dtype2 = type(answer_dict['Q6'][0][1])
        dtype3 = type(answer_dict['Q6'][0][2])
        dtype4 = type(answer_dict['Q6'][0][3])
        dtype5 = type(answer_dict['Q6'][0][4])
        dtype6 = type(answer_dict['Q6'][0][5])
        self.assertEqual([dtype1, dtype2, dtype3, dtype4, dtype5, dtype6], [str, float, float, float, float, float])

    def test_Q6_check_first_and_last_brand(self):
        first_brand = answer_dict['Q6'][0][0]
        last_brand = answer_dict['Q6'][4][0]

        self.assertEqual([first_brand, last_brand], ["Toyota", "Honda"])

    def test_Q7_dim(self):
        self.assertEqual(np.array(answer_dict['Q7'], dtype=object).shape, (7,2))

    def test_Q7_types(self):
        dtype1 = type(answer_dict['Q7'][0][0])
        dtype2 = type(answer_dict['Q7'][0][1])
        self.assertEqual([dtype1, dtype2], [tuple, float])

unittest.main(argv=[''], verbosity=2, exit=False)

"""Save your answers
> First, take a moment to evaluate your answers and make sure you have not missed anything
> Use the following code to save your answers in pickle format, change the filename using the following format:

FIRSTNAME_LASTNAME_answers.pkl
Example: Juan_Perez_answers.pkl
If you are using google colab you can find your file on the left side bar by clicking the folder icon inside the sample_data folder. Remember to upload the pickle file and the notebook to github and submit their URLs to the google form.
"""

answer_dict

import pickle

file_name = "EMMANUEL_ANYIRA_answers.pkl"
path = ""

with open(path+file_name, 'wb') as f:
    pickle.dump(answer_dict, f, protocol=pickle.HIGHEST_PROTOCOL)